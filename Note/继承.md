## 第13章 继承 ##


基类中含有静态成员，则整个继承体系中只含有唯一的一个静态成员。

`final`使用在类后面防止类被继承；
```C++
class NoDerived final{/**/};
```

using语句可以将对于派生类可访问的直接基类和间接基类成员修改其访问权限，在派生类中访问权限取决于using 所处的访问权限说明符。同样using 可以用于函数，只需要在using后面跟函数名就可以将所有重载版本的函数添加到派生类作用域中，对于需要 特定定义的函数再定义即可。



1. 继承分为：共有继承、私有继承、保护继承。

3. 多态公有继承可以实现同一方法在基类和派生类中有不同的行为，实现方式是：虚函数 + 重新定义函数。

4. 防止继承的发生：不希望某个类再被继承(不能作为基类)，则可以在类 后面增加关键字`final`(C++11):
    ```c++
        class NoDerived final{/* */};
    ``` 

5. 受保护的成员(protected):派生类的成员或友元只能通过派生类对象来访问基类受保护的成员

    + 类用户不能访问，但是类的派生类的成员和友元可以访问。

    + 派生类的成员和友元只能通过派生类对象来访问基类的受保护成员。
        ```C++
            class Base{
            protected:
                int prot_mem;
            };
            class Sneaky: public Base{
                friend void clobber(Sneaky&);
                friend void clobber(Base&);
            }
        ```
        + 其中第一个clobber可以访问`Sneaky::prot_mem`,第二个clobber不能访问`Bsae::prot_mem`。 


**派生类访问说明符对派生类的成员(及友元)能否访问其直接基类的成员没有什么影响，对其成员的访问权只与访问说明符有关。派生访问说明符的目的是控制派生类用户对基类成员的访问权限。**

派生类向基类的转换(假设D继承自B)

1. **对于使用类的对象的代码**：只有当D是公有继承B的时候才可以使用派生类向基类的转换，因为派生类访问说明符限制了派生类对象的基类部分对于对象使用用户的可见性。派生类的基类部分只有当公有继承是才可见，其余的都不可见。

2. **对于派生类的成员函数和友元**：无论D使用什么方式继承B，都可以使用派生类向基类转换。因为派生访问说明符不影响派生类成员和友元的访问权限，但是访问说明符有限制。

    + 派生类成员函数使用基类对象只能访问基类的`public`和`protected`成员。

    + 派生类友元函数使用基类对象只可以范访问`public`成员，如果需要访问基类的`protected`成员职能使用派生类对象。

3. **对于派生类的派生类的成员函数和友元**：如果D继承B的方式是`protected`或者是`public`，则D的派生类可以使用D向B的类型转换。因为在`private`的派生方式下，对于D的派生类的成员或者友元其直接基类D的基类部分是不可见的；

### 公有继承(is-a 关系) ###

1. 公有继承：基类的公有方法成为派生类的的公有方法。但是派生类的成员(及友元)还是无法直接访问基类的私有成员，除非使用基类接口访问

    + 公有继承派生类继承基类的接口。

### 私有继承(has-a 关系) ###

1. 私有继承：基类的共有成员和保护成员都成为派生类的私有成员。但是派生类的成员(及友元)还是无法直接访问基类的私有成员，除非使用基类接口访问。

    + 所有的数据成员和函数成员都成为派生类的**私有成员**。
    
    + 基类的公有方法不会成为派生类的接口，但是派生类成员函数可以使用。

    + 私有继承派生类**不继承**基类接口。

    + 私有继承获得实现，不获得接口。

2. 实现`has-a`关系的方式有：

    + 包含对象(在类中包含该类的对象)：在类中添加一个命名的对象。

    + 私有继承：在类中添加一个未命名的对象。

3. 包含和私有继承的选择(建立has-a关系时)：

    + 一般使用包含建立has-a关系。

    + 新类需要访问原有类的保护成员、或者需要重新定义虚函数则使用 私有继承。

![各种继承的关系][]

### 保护继承(has-a 关系) ###

1. 保护继承：基类的公有成员和保护成员都成为派生类的保护成员。但是派生类的成员(及友元)还是无法直接访问基类的私有成员，除非使用基类接口访问

    + 派生类内部可以使用基类的共有成员。

    + 基类的接口不再是派生类的接口。

2. 保护继承和私有继承的差别：在于第三代派生类

    + 保护继承的第二代派生类内可以使用基类的公有成员，而私有继承不能使用。

    |公有成员|   基类| 第一代派生类|          第二代派生类| 
    |-------|-------|--------|-----------------------|
    |私有继承|公有成员|私有成员|     只有基类成员才能访问|
    |保护继承|公有成员|保护成员|保护成员，类内成员可以访问|

### 派生类向基类的转换(向上转换，假定D继承自B) ###

1. 对于使用类的对象的用户(代码)：只有D公有继承B时，用户代码才能使用派生类向基类的隐式转换。受保护或私有继承都不能使用该转换。

    + 原因在于：私有/保护继承之后，对于类的对象的使用者来说，基类(匿名)对象在派生类中是私有/受保护的，不能够访问。

2. 对于编写派生类的用户来说：不论D以什么方式继承B，D的成员函数和友元都可以使用该转换。

    + 原因在于：在派生类D里面，通过public/private/protected 继承之后，相当于给基类的(匿名)对象相应的增加了访问控制权public/private/protected，但是在派生类里面仍可以访问该基类匿名对象(作为一个整体访问)，但是无法访问基类匿名对象的私有成员。

3. 对于D这个派生类的派生类来说：D继承B的方式是public/protected，则D的派生类；则D的派生类的成员函数和友元可以使用D向B的类型转换，否则不行。

    + 原因在于：假设D的派生类是F，D继承B的方式是public/protected，那么，在D里面基类B的匿名对象的访问控制权为public/protected，则D的派生类F的成员函数和友元都可以访问基类B的对象，根据第2点，和F继承D的方式无关。

### 虚基类/虚继承 ###

1. 虚基类：主要是用来解决多重继承的基类来自同一祖先的情况。

2. 当基类是虚的时，禁止信息通过中间类传递给基类，因此在写构造函数的时候需要做一些修改：按顺序显示的调用所需的基类构造函数。

### 虚函数 ###

1. 虚函数工作原理：编译器给每个对象添加一个隐藏成员，该成员是一个指向函数地址数组的指针(函数指针数组指针)，其中这个函数地址数组成为**虚函数表**(virtual function table, vtbl),虚函数表中存储的是类对象进行申明的虚函数的地址。**每个对象中增加一个隐藏的指针成员，都指向同一个虚函数表，该虚函数表属于类。**

    + 基类定义的虚函数，基类对象中有指针指向虚函数表，虚函数表中存储基类虚函数地址。

    + 基类定义的虚函数，但是派生类中没有重新定义，则派生类对象中指针指向的虚函数表的相应的位置的值不变。

    + 基类定义的虚函数，派生类中重新定义该函数，则派生类对象指针指向的虚函数表相应的位置更新为派生类重新定义的函数的地址。

    + 在派生类中新定义的虚函数，则派生类对象中指针指向的虚函数表新增该函数的地址。

2. 使用虚函数的成本：

    + 每个对象都增加一个指针成员，即对象增大一个地址空间；

    + 每个类编译器创建一个虚函数表(数组)；

    + 对于虚函数的调用，都必须先查虚函数表，造成一定额外操作。

3. 非虚函数使用静态联编(静态绑定)，虚函数使用动态联编(动态绑定)。

    + 动态绑定：在运行时选择函数的版本。


4. 一但某函数被声明为虚函数，在其派生类中都是虚函数，因此可以不用在派生类中声明该函数为虚函数，可以在类成员函数声明的函数后面关键字`override`注明(C++11新标准)。
    + 如果用`override`标记了某函数，但是没有覆盖基类的函数则会报错，利于错误发现。

5. 派生类中虚函数的参数列表以及返回类型应与基类的一致，只有基类当虚函数的返回类型是该类本身的引用或指针时，派生类中虚函数返回类型也可以是来生类自己的引用或指针。

6. 若某函数是虚函数，则当不允许其后面的派生类覆盖该函数的时候可以在类声明中使用`final`来禁止其派生类覆盖。
    ```C++
        void function() final;
    ```

7. 虚函数可以函数默认实参，当通过基类的指针或者是引用来调用函数的时候，函数的默认实参有基类决定，即使运行的是派生类的函数(虚函数的参数类表一致，但是默认实参可以不一致)。即：拥有默认实参的虚函数，在使用默认实参的时候，默认实参由静态类型的类定义的虚函数的默认实参决定。

    + 一般建议如果虚函数使用默认实参，派生类的虚函数的默认实参和基类保持一致。


8. 回避虚函数机制：使用作用域限定符指定是某作用域的函数。需要回避虚函数机制的情况是派生类的虚函数需要调用其要覆盖的基类虚函数的时候。
```C++
Base* pBase = &Derived; //有虚函数visualfun()
pBase->visualfun(); //动态绑定，调用的是Derived::visualfun()
pBase->Base::visualfun(); //指定调用的是Base::visualfun()
```

9. 虚函数的覆盖需要有相同的调用形式(即相同的参数列表以及返回类型)，只有当返回类型为类本身的指针或者引用时，派生类可以可以返回派生类的指针或引用。当派生类中含有与基类中虚函数相同的名字但是参数列表不同则编译器认为派生类并没有覆盖基类的虚函数，即这是两个不同的函数。

### 抽象基类 ###

1. 含有纯虚函数的类，成为抽象基类。抽象基类负责定义接口，后续的其他类可以覆盖该接口，但是不能创建抽象基类的对象，抽象基类只能作为基类。

2. **纯虚函数**：在虚函数声明结尾处为`= 0`的函数。可以不为其提供函数实现，但是如果提供实现也可以必须在类外部，不能再类内部提供。
```c++
    virtual function() = 0;
```



### `struct`和`class`的差别 ###

1. `struct`的默认成员访问说明符是`public`,`class`的默认成员访问说明符是`private`。
    + 在struct里面不加访问控制符，默认是public，而class相反。

2. `struct`的默认派生访问说明符是`public`,`class`的默认派生访问说明符是`private`。
    + 在派生的时候，不使用派生访问说明符的时候，struct默认是公有派生，class相反。



### 作用域 ###

1. 派生类作用域在基类作用域内。

2. 当一个名字在派生类中无法解析的时候，会继续在其外层的基类中查找。

    + 也正因为如此，派生类里面和直接基类或间接基类同名的冲突下，派生类中的名称会隐藏基类的相同的名称(包括数据成员和函数成员)。

3. 对于内层作用域(派生类)内和外层作用域(基类)同名的函数,即使参数列表不一样也不会重载，相反会将外层作用域的同名函数隐藏。如果需要调用隐藏的函数则需要指出其作用域。


## 多重继承 ##

## 虚继承##

多重继承中派生列表中每个基类只能出现一次，但是一个派生类可以间接的多次继承同一个基类：

1. 派生列表中有两个不同的直接基类，但是连个直接基类都派生自同一个基类。

2. 派生类的直接基类中，有一个直接基类派生自另一个。

如果一个类多次继承了某一个基类，则该类中含有多个该基类的子对象。在某些类中不希望出现过个基类的子对象，而是想实现尽管多次继承但是只有基类的一份子对象，可以使用**虚继承**。**虚继承**是指某个类在派生的时候做出申明愿意共享他自己作为派生类的虚基类。共享的类的子对象称为派生类的**虚基类**。无论继承多少次，派生类中只一个**共享的**虚基类子对象。

**虚基类中成员可见性 《C++ Primer 719》**

为避免二义性，最好的方式是在派生类定义自己的新实例。

**虚继承的构造方式**

一个类含有虚基类，则虚基类的初始化是由这个类来完成的，即由最底层的派生类来完成。含有虚基类的类的构造顺序：首先按照在派生列表中出现含有虚基类的次序，依次构造虚基类；其次在按照派生类列表构造非虚基类。如果该类没有初始化其虚基类则编译器会调用默认构造函数来初始化，如果虚基类没有默认构造函数则出现错误。

+ 合成的拷贝构造函数、移动构造函数也按照相同顺序执行，合成的赋值运算符也按照相同顺序赋值。 

[各种继承的关系]:./image/继承.png