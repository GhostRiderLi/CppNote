# 异常 #
****

## 运行时类型识别(run-time type identification, RTTI) ##

1. typeid运算符，用于返回表达式的类型。

2. dynamic_cast 运算符，将基类指针或者引用安全转换成派生类的指针或引用。

3. 适用场合：当我们想使用基类对象或指针执行某个派生类的非虚函数方法。

### dynamic_cast ###

1. type为一个类类型，一般情况下有含有虚函数。则下面三种方式中转换成功的条件是下面之一：

    + e的类型是type类型的**共有派生类**(公有派生类-->直接或间接基类)。

    + e的类型是type类型的**共有基类**(基类 ---> 公有派生类)。

    + e 和type同类型。 
    ```C++
        dynamic_cast<type *>(e)
        dynamic_cast<type &>(e)
        dynamic_cast<type &&>(e)
    ```

2. 对于指针，如果转换成功，则返回指针所指对象的地址，否则返回空指针。

3. 对于应用，转换失败的时候则会抛出`std::bad_cast`的异常，该异常定义在typeinfo头文件中。


### typeid ###

`typeid运算符`是一个能够返回对象类型的运算符。使用方式是`typeid(表达式/类型名)`，返回值是一个`type_info`对象的常量引用。

1. `typeid`作用于数组或者函数时不会像指针的标准形式转换，如当作用于数组时返回的是数组类型，不是指针类型。

2. 对于使用指针指向的对象或者引用绑定的对象，取决于对象是够含有虚函数返回其静态类型或者动态类型。

3. `typeid`作用于对象，当作用于指针时，返回的是指针的静态类型。

4. `typeid(*p)`如果p指向的静态类型和动态类型不同则需要运行时求值才能确定返回类型，此时指针必须有效；当静态类型和动态类型相同时，无需求值也能知道返回类型，因此此时指针可以不有效。


## 异常处理 ##



# 命名空间 #

命名空间的定义使用`namespace`，在命名空间内部可以包括类、变量、函数(及其定义)、模板和人其他命名空间。**命名空间需要在其作用域内部保持唯一**
```C++
namespace Name{
    /* 命名空间内部的元素 */
}
```
命名空间可以是不连续的，因此命名空间的组织方式类似类与函数：

1. 命名空间中定义类，以及申明作为类接口的函数及对象(类的接口定义，类的接口函数定义、对象申明)放在头文件中，被包含在相应的源文件中。

2. 命名空间中具体的实现接口部分则保存在源文件中，包含相应的头文件。

命名空间的成员定义可以在命名空间内部也可以在命名空间外部。当在命名空间外部定义是必须指明其作数的命名空间前缀，与类的外部定义成员函数类似。命名空间外部定义成员意味着在其外部的命名空间定义，这个命名空间必须和自身有一定关系，不能是另外一个独立的命名空间定义。同时对于**模板特例化**成员的定义必须在命名空间内部定义，不能再外部定义。

**全局命名空间**：指文件中左右函数，组有泪所处的命名空间，可以使用`::member_name`访问全局命名空间的成员。

**内联命名空间**中的成员可以被外层命名空间直接使用，不像普通命名空间需要加上其命名空间名。表示如下：
```C++
inline namespace name{

}
```
1. 对于内联命名空间第一次申明时需要加上关键字`inline`，后面就可以不使用这个关键字.

**未命名的命名空间**

未命名的命名空间可以在一个文件内部不连续，但是不能跨越文件。未命名的命名空间中定义的名字的作用域和该命名空间作用域相同。该未命名的命名空间的成员可以被其外一层的命名空间直接访问，不能使用作用域限定符。申明形式如下：
```C++
namespace{ 
}
```
1. 未命名的命名空间内部的成员具有**静态生命周期**：第一次使用前创建，直到程序结束才销毁。这个C++11的特性已经取代了C中的静态成员申明。


**命名空间的别名**

命名空间可以使用别名，`namespace NewName = OldName`。



## 枚举类型 ##

枚举类型属于字面值产常量，在C++中含有两种枚举类型：限定作用域和不限定作用域的枚举类型。

1. 限定作用域的枚举类型：遵循作用域规则，使用成员时需要限定作用域
    ```C++
    enum class open_mode{input, output,append};
    enum struct open_mode{input, output,append};
    open_mode mode = open_mode::input;   //正确
    open_mode mode = input;     //错误
    ```
2. 不限定作用域的枚举类型：没有限定作用域可以直接使用，也可以显式使用作用域限定
    ```C++
    enum color{red, yellow, green}; //
    enum {red = 10, yellow = 20, green = 30}; //
    ```
    + 可以向整型隐式转换`int i = color::red`

想定作用域枚举类型的成员实际上是使用整型`int`表示的，不限定作用域的枚举类型没有默认类型，但是足够大。在C++11中我们可以指定enum使用的类型，当超过这个类型值会报错：
```C++
enum intValus: unsigned long long{
    ···
};
```


