# 操作符重载 #

## 重载基础 ##

![operator][]

操作符分为一元操作符和二元操作符。一元操作符有一个参数，二元操作符有两个参数。`+, -, *, &`既是一元操作符也是二元操作符，可以从参数看出来。对于二元操作符，操作符的左边对象传递给函数的第一个参数，操作符右边的对象传递给函数的第二个参数。 除了重载的函数调用运算符`operator()`之外，其他重载运算符不能含有默认实参。

**通常情况下不应该重载的操作符有`, & && ||`**原因：

1. 重载函数版本无法保留他们的求值顺序或者是短路求值属性；

2. ，和 & C++已经定义了内置的特殊含义。 

## 操作符重载的方式与选择 ##
 
操作符的重载方式有两种，以成员函数方式重载或者以友元函数重载。除了`= () [] ->`四个运算符只能通过成员函数进行重载之外，其他的可重载运算符可以通过成员函数或者非成员函数(友元函数)来重载。使用成员函数重载意味着该对象作为第一个操作数，使用友元函数重载则可以选择运算符的操作数的顺序。

操作符重载方式的选择原则：

1. 不能重载的运算符有：`::, .*, .,  ? :`

1. `= () [] ->`四个运算符只能通过成员函数进行重载；

2. 具有对称性的运算符可能转换任意一端的运算对象，使用非成员函数重载(友元函数)如算术，相等性，关系和位运算。

## 几个重要操作符重载 ##

1. 输出运算符`operator<<`  **二元操作符，必须以友元函数重载**
    ```C++

    ostream &operator<<(ostream &os, const T &t){
        ···
    }
    ```
    + 第一个参数为 **非常量对象引用**：输出流写入内容会改变其状态；

    + 第二个参数为 **常量引用**：使用引用避免拷贝；

    + 返回参数为**输出流引用**；

2. 输出运算符`operator>>`  **二元操作符，必须以友元函数重载**
    ```C++

    istream &operator<<(istream &os, const T &t){
        ···
    }
    ```
    + 第一个参数为 **非常量对象引用**：输入流写入内容会改变其状态；

    + 第二个参数为 **常量引用**：使用引用避免拷贝；

    + 返回参数为**输入流引用**；

    +　输入运算符需要处理可能遇到的出错的情况，输出运算符不需要。

3. 加法运算符`operator+`：    **二元操作符，以友元函数重载**
    ```C++
    t operator+(const T& t1, const T &t2){
        ···
    }
    ```
    + 第一个参数为 **常量对象引用**

    + 第二个参数为 **常量引用**：使用引用避免拷贝；

    + 返回参数为 **变量**；

4. 相等运算符 `operator==`和 不等运算符`operator!=`
    ```C++
    bool operator==(const T &t1, const T &t2){
        ···
    }
    bool operator!=(const T &t1, const T &t2){
        return !(t1 == t2);
    }
    ```

    + `==`与`!=`定义其中一个之后，另外一个可以调用。

5. 关系运算符            **二元操作符  以成员函数重载**
    ```C++
    bool operator<(const T &t1, const T &t2){
        ···
    }
    bool operator>(const T &t1, const T &t2){
        ··· 
    }
    ```

    + 定义原则：(1) 定义的顺序应该和关联容器的关键字要求一致(一般是定义小于符号)；(2)如果存在唯一一种可靠的<的定义，则考虑为这个类定义<运算符，如果类同时包含`==`号则只有`<`的定义与`==`产生的结果一致时才定义小于运算符。


6. 赋值运算符(分为拷贝复制运算符和移动赋值运算符)   **二元操作符  以成员函数重载**
```C++
T& operator=(const T& rhs){
    if(this != &rhs){
        ···
    }
    return this;
}
```
    
    + 判断是否是自赋值；

    + 先分配空间，建立赋值的副本(可以是动态分配，也可以不是)，目的是保证发生异常之前保持原对象不变，使其异常安全；

    + 先释放当前内存空间，再赋值；

    + 当使用初始化列表当做参数时，不需要检测是否是在对自己赋值。

7. 复合赋值运算符                      **二元操作符  以成员函数重载**
    ```C++
    T& operator+=(const T& t){
        ···
        return *this；
    }
    ```

    + 返回左侧运算对象的引用。

8. 下标运算符            **必须是成员函数**
    ```C++
    T& operator[](std::size_t n){
        ···
    }
    const T& operator[](std::size_t n) const {
        ···
    }
    ```
    + 定义下标运算符的时候，一般同时定义两个版本：一个返回普通引用，可以修改应用的值，一个返回常量引用的常量函数成员。

9. 递增、递减运算符               **以成员函数重载**

    + 同时定义前置版本和后置版本，形式上通过一个不会被只用的形参区分前置和后置版本；

    + 前置版本:**返回递增或递减后的对象的引用**
        ```C++
        T& operator++(){
            //第一步检查指针是否指向了容器的尾后位置，是则无法递增
            //自增
            return *this//返回对象
        }

        T& operator--(){
            //自减
            //检查自减后是否合法
            return *this//返回对象
        }
        ```

    + 后置版本：**返回局部对象**
        ```C++
        T operator++(int){
            T tmp = *this；//记录当前值
            ++*this；//调用前置递增版本
            return tmp；
        }
        T operator--(int){
            T tmp = *this;
            --*this; //调用前置递减版本
            return tmp;
        }
        ```

    + 显示调用：
        ```C++
        t.operator++(0) //调用后置版本
        t.operator++()  //调用前置版本
        ```

10. 成员访问运算符`->`：    **使用成员原函数重载**

[operator]:./image/operator.jpg
