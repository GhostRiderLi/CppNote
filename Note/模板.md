## 模板 ##

### 函数模板 ###

1. **函数模板**并不建立任何的函数，只是告诉编译器如何定义函数。只有在使用的时候才会实例化，生成相应的**模板函数**。

2. 在使用函数模板的时候，使模板生成相应的函数定义，这个过程称为实例化。

    + 隐式实例化：不具体指明模板中类型参数，直接调用模板，使编译器自动推导相应的参数。如：
    ```C++
        // 模板函数
        template <typename T>
        void swap(T& i, T& j){
            ...
        }
        int i = 10, j = 5;
        //使用时编译器通过参数推导出 模板中T为int，生成void swap(int&， int&)的函数定义
        swap(i, j);  //隐式实例化
    ```

    + 显式实例化：使用模板时指定实例化的类型，主要用于弥补隐式实例化编译器不能正确自动推导的情况，并且，在声明时就已经将函数模板实例化。
    ```C++
    swap<int>(i, j);
    //申明时的语法：
    template void swap<int>(int &, int &); //只需要声明就可以
    ```

3. 显式具体化：显式具体化也是基于函数模板的，只不过在函数模板的基础上，添加一个专门针对特定类型的、实现方式不同的具体化函数。显式具体化的声明如下,两个是等效的：
    ```C++
    template <> void swap<int>(int &, int &);
    template <> void swap(int &, int &);
    template <> void swap(int & a, int & b){  //具体化需要重新定义
        ···
    }
    ```
4. 对于同一个函数名，编译器选择函数原型的时候的顺序是：非模板版本 >  显示具体化  >  模板版本。

### 类模板 ###

1. 隐式实例化：编译器在使用对象之前不会实例化。

2. 显式实例化：当使用template指出所需要类型来申明类的时候，编译器将生成类声明的显式实例化。申明格式如下：`template calss ArrarTP<string, int>;`

3.显式具体化：主要是针对特定类型，不适合使用类模板的时候，定义具体化类模板。
    `template <> class Classname <specializad-type-name>{···};`



