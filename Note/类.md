# 类

## 类的行为

## 数据成员 

### 静态数据成员

静态成员只属于类，不属于对象，所有的对象都共享同一个静态成员。静态成员的申明是使用`static`关键字。

#### 静态数据成员的访问

静态数据成员的使用时使用作用域运算符访问，可以使用对象或引用`.`操作访问，也可以使用对
象指针的`->`访问。

#### 静态数据成员的初始化

静态数据成员不属于任何一个对象，因此静态数据成员的初始化不是构造函数初始化的。初始化方式有如下几种：

1.  在类的内部申明静态数据成员(使用关键字`static`)，在类外部定义、初始化静态数据成员(
    不需要使用`static`);**一般都是用这种方式**
    ```C++
    class Account{
    public:
        static double  route;
        /*...*/
    }
    double route = 0.0;
    ```

    >想要确保对象只定义一次静态数据成员，最好的方法就是将静态数据成员和非内联函数定义在同一个文件内，即定义在.c文件，而不是定义在头文件。

2.  在类内部申明、初始化静态数据成员，在类外部定义静态数据成员；

    >可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。

    + 即，当静态数据成员是constexpr的常量表达式才能使用const整型在类内初始化，当在类内申明、初始化之后，通常在类外也需要不带初始值的定义。

#### 静态数据成员与普通数据成员的差别

1.  静态数据成员可以是不完全类型；静态数据成员可以是他所属的类的类型，但是普通数据成员
    只能是他所属类的指针/引用。
    ```C++
    struct List{
        /* List 从这里开始是一个不完全类型 */
        int data;
        List* next; //定义了一个不完全类型的指针
        /* List 从这里结束是一个不完全类型 */
    }
    ```

    >在一个类型申明之后，定义结束之前的范围内，这个类型是一个不完全类型，即已知是什么类型，但是不知道具体的内容。可以定义这种不完全类型的**指针或者引用**、以及申明以不完全类型**作为参数或者返回类型**的函数。


2.  静态数据成员可以作为默认实参，普通数据成员不能作为默认实参。

### 类型成员

类型成员是指在类内部对一些类型定义的别名。类型成员需要**先定义，后使用，因而一帮出现在
类开始的地方，一般public**，例如标准库中`const_iterator`就是类型成员。定义类型类型成
员的方式两种：
```C++
typedef std::string::size_type pos; //version 1
using pos = std::string::size_type; //version 2
```



## 函数成员 

### 构造函数

构造函数名字与类名称相同，没有返回值，参数可以自己定义，没有参数的构造函数称为零构造函数，也可以说是默认构造函数。构造函数可以有多个，分别有不同的参数(构造函数可以重载)。 构
造函数可以分为： 默认构造函数、 拷贝构造函数、 移动构造函数、 委托构造函数。


**构造初始化列表**

构造函数尽量使用初始化列表来初始化数据成员，但是**初始化顺序需要和定义顺序相同**，为了防止有联系的数据成员和初始化顺序有关系造成初始化错误。

**构造函数不能申明为const函数**

在创建一个const对象时，直到构造函数初始化完成对象才能或得**常量**的属性。

**构造函数不能申明为虚函数**


#### 默认构造函数

对一个没有定义构造函数的类会通过一个默认构造函数来初始化对象。这个由编译器合成的构造函数也称为合成默认构造函数。当定义了其他的构造函数编译器便不会生成默认构造函数，此时需要显式的定义默认构造函数，**默认构造函数没有任何参数**，如果我们需要默认的行为则可以声明
默认构造函数，在后面使用`=default`来要求编译器生成默认构造函数。

为了防止构造函数发生意料之外的默认类型转换、或者限定只能按照某一形式构造对象可以在函数
前使用`explicit`指定。

#### 委托构造函数

委托构造函数也是一个构造函数，但是把一部分初始化委托到爱他的构造函数上面，实际上使用的时候就是**在初始化列表调用了其他的构造函数**这和继承的子类的构造函数类似。

#### 拷贝构造函数

用户没有定义自己的拷贝构造函数，则编译器会自己合成一个默认的复制构造函数成为**合成默认
拷贝构造函数**，当存在深浅拷贝问的时候，需要根据自己需求定义拷贝构造函数。 调用拷贝构造
函数的场合有：

+   定义一个对象，并且使用`operator=`为其初始化(拷贝初始化)；

+   一个对象作为实参传递给一个非引用类型的形参；

+   一个返回类型为非引用类型的函数返回一个对象；

+   使用花括号列表一个数组中的元素或一个聚合类中的成员；

**拷贝构造函数的参数**

拷贝构造函数的参数必须是**(const)引用类型**。如果拷贝构造函数不是引用类型，则当调用复
制构造函数的的时候，又会调用拷贝构造函数(非引用类型传参调用拷贝构造函数)，造成循环调用
。 申明形式如下：
```C++
Foo(const Foo&);
```

#### 移动构造函数


### 析构函数

析构函数是类的一个成员函数，没有返回值，不接受参数。主要用来销毁对象的非`static`成员。
在析构函数中首先执行函数体，然后按照初始化顺序的逆序销毁成员。 析构部分是隐式的。**析构
函数可以是虚函数**

对于内置类型的指针，隐式销毁并不会delete指针所指的对象。 析构函数体本身并不直接销毁成
员，成员是在析构函数体之外的析构阶段中被销毁的。申明形式：
```C++
~Foo();
```

**调用析构函数的场合**： 当指向对象的引用或内置指针离开作用域时，析构函数不会执行

+   变量离开作用域；

+   对象被销毁的时候，其成员也被销毁(会调用自己的析构函数)；

+   容器被销毁，其元素被销毁的时候。

+   临时对象，创建的表达式结束时

+   对于动态分配的对象，使用delete时；

#### 虚析构函数

虚析构函数可以保证在动态类型和静态类型不一致的情况下(动态绑定时)能够正确销毁对象。在使用虚析构函数的时候，会阻止编译器合成移动操作，如果需要移动操作需要自己定义或者显式定义(`default`)。

虚析构函数一般在基类中定义，如果基类中定义了虚析构函数则会导致基类以及其派生类不能让编译器合成移动操作，因此，如果派生类需要移动操作，则在基类中就可以定义对应的移动操作，则派生类在显式定义移动操作后才会有效，而不会被定义为删除的移动操作，示例如下：
```C++
class Base {
public:
    Base() = default;
    Base(const Base&) = default;
    Base(Base&&) = default;   // 移动构造
    Base& operator=(const Base&) = default;
    Base& operator=(Base&&) = default;   // 移动赋值操作
    virtual ~Base() = default; //基类使用了虚析构函数，需要显式定义移动操作
private:
    int mem = 45;
};
```

### 赋值函数

#### 拷贝赋值函数

如果用户没有定义拷贝赋值运算符，则编译器也会合成一个。拷贝赋值运算符应该返回一个对象的引用,参数为对象的常量的引用，必要时做自赋值检测。具体内容见[运算符重载][]
```C++
type& operator=(const type&);
```

##### 拷贝赋值运算定义的常用形式
```C++
/*
version1: 兼顾了异常安全性和自赋值检测但是即使不是自赋值都要检测，自赋值发生机会不多因此反而会使效率降低,
结论：异常安全性已经可以处理自赋值情况，没有必要再次显式处理自赋值。
 */
Derived& operator=(const Derived& rhs){
    if(this != &rhs){
        //如果有基类，则先拷贝基类部分成员
        Base::operator=(rhs);
        // 拷贝rhs的非基类部分到副本
        // 释放当前对象内存
        // 将副本赋值到当前对象
    }
    return *this;
}
/*version2: 拷贝赋值自赋值的情况下也不会出问题*/
Derived& operator=(const Derived& rhs){
    
    //如果有基类，则先拷贝基类部分成员
    Base::operator=(rhs);
    // 拷贝rhs的非基类部分到副本
    // 释放当前对象内存
    // 将副本赋值到当前对象
    
    return *this;
}
/*同样是异常安全，构造临时对象异常不会影响本对象，同时已经处理了自赋值*/
Derived& operator=(const Derived& rhs){
    Derived tmp(rhs); //重新构造一个对象副本
    swap(*this, tmp); //临时对象和本对象交换
    return *this;
}
```

##### 拷贝赋值运算符调用的情况

+   定义对象，并且使用`=`初始化，调用的是类的构造函数；

+   不是定义对象，使用`=`赋值的时候：

    +   `=`右边是该类的对象，调用拷贝赋值运算符函数

    +   `=`右边不是类的对象，但是可以由构造函数构造成为类，则先调用构造函数，在调用拷贝赋值运算符函数。

##### 拷贝赋值运算符 vs 拷贝构造函数

拷贝构造函数和拷贝赋值运算不能互相调用。二者目的不一样

1.  拷贝构造函数目的在于创建一个新对象，是用来初始化一个新的对象；

2.  拷贝赋值运算是在一个已经初始化过的对象上重新赋值，其操作包括两部分释放`=`左边的值，使用`=`右边的值来初始化。对于拷贝构造函数来说没有第一步。

3.  **解决办法**：对于相同的操作可以新建一个`private`函数来处理，拷贝构造函数和拷贝赋值预算在来调用，一般命名为`init`;


#### 移动赋值函数

移动赋值函数的常用形式：
```C++
//移动拷贝必须检测自赋值
Derived& operator=(Derived&& rhs){
    if(this != &rhs){
        //如果有基类，则先拷贝基类部分成员
        Base::operator=(std::move(rhs));
        //派生类元素直接移动
        //对于指针需要置于可析构状态(设置为nullptr)
    }
    return *this;
}
```

### 构造函数&赋值函数总结

### 移动构造函数&移动赋值函数 

**合成移动操作条件**

只有当类没有定义任何自己的拷贝控制成员(拷贝构造函数、拷贝赋值函数)，且每个非`static`成员都可以移动时，编译器才会合成相应移动操作。

1. 内置类型本身可以移动

2. 非内置类型，自己定义了移动操作，则可以移动

**移动操作被定义为删除的情况**
    
1. 有类成员定义了拷贝构造函数/拷贝拷贝赋值，但是没有(显式)定义移动构造函数/移动赋值；
    
    + 即使显示定义拷贝构造函数/拷贝拷贝赋值为删除的(`=delete`)，也不会相应的成移动操作。

2. 有类成员没有定义拷贝构造函数/拷贝拷贝赋值，但是编译器不能为其合成移动构造函数/移动赋值；

3. 有类成员的移动构造函数/移动赋值被定义为删除的或者是不可访问的；

4. 有类成员是const的或者是引用；

5. 类的析构函数被定义为删除的或者是不能访问的；

6. 类使用了虚析构函数，则阻止该类合成移动操作，即使虚析构函数使用的是`= default`,也会阻止合成移动操作。
    
    + 如果需要移动操作，则需要自己定义移动操作或者显式定义使用`= default`的移动操作。

**如果没有移动操作，右值也会被拷贝**

**三/五法则**

五个拷贝控制成员：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符、析构函数。只要定义了其中的任何一个，就应该全部定义这五个操作。

#### 合成默认xx函数

当用户没有申明构造函数、拷贝构造函数、析构函数、拷贝赋值函数的时候，编译器会自动生成对应的**合成默认xx函数**。

需要析构函数的类也需要拷贝构造函数和拷贝赋值函数；需要拷贝赋值函数的类也需要拷贝构造函数，反过来也一样，但是不一定需要析构函数。

**使用默认合成函数**

用户可以在需要的时候自己定义构造函数、拷贝构造函数、析构函数，但是如果需要默认的合成版本的函数可以使用`=default`来显示说明使用默认的合成版本。但是，`=default`使用在类内申明的地方，表示申明为内联的(inline),如果不希望生成内联版本，则在定义的时候使用。**拷贝赋值函数不能使用default**。

**合成的拷贝控制函数也可能是删除的，以下的情况是删除的**：

一个类有不能默认构造、拷贝、复制、销毁的成员则对应的函数被定义为删除的。

1. 类的某个成员的析构函数是删除的/不可访问的(`paivate`),该类的合成析构函数是删除的；

2. 类的某个成员的析构函数是删除的/不可访问的(`paivate`),类的合成拷贝构造函数是删除的； 

3. 类的某个成员的拷贝构造函数是删除的/不可访问的(`paivate`),类的合成拷贝构造函数是删除的；

4. 类的某个成员的拷贝赋值函数是删除的/不可访问的(`paivate`)，类有一个const成员，类有一个引用成员，类的合成拷贝赋值函数是删除的； 

5. 类的某个成员的析构函数是删除的/不可访问的(`paivate`)，类有一个没有类内初始化其的const成员，且其类内没有显示定义默认构造函数，默认构造函数定义为删除的。 

6. 类有一个没有内类初始化其的const成员，且该成员类内没有显示定义默认构造函数，默认构造函数定义为删除的。 


**派生类中拷贝控制和基类的关系**

1. 基类的默认构造函数、拷贝构造函数、拷贝赋值运算或者是析构函数是删除的/不可访问的(`private`)，则派生类中对应的函数也是删除的。 

2. 基类的析构函数是删除的/不可访问的(`private`)，则派生类中合成的默认构造函数、拷贝构造函数、移动构造函数将是被删除的。


3. 基类中的移动操作是删除的/不可访问的(`private`)，即使使用`=default`来请求一个移动操作，也将是删除的移动操作。

#### 阻止类的拷贝

对于某些类，其拷贝函数的存在是不符合逻辑的，在这些类里面可以使用一些方式阻止。

1.  **定义删除的函数(C++11)**
```C++
struct NoCopy{
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete;
    NoCopy& operator=(const NoCopy&) = delete;
    ~NoCopy() = default;
};
```
    +   在类内部申明时，在参数列表之后使用`=delete`表示阻止该操作(拷贝构造函数、拷贝赋值函数)。

    +   `=delete`实际上可以给类内任何成员使用，但是一般析构函数不定义为删除的函数。

2.  **使用`private`，并不实现该函数**
```C++
class NoCopyBase{
public:
    NoCopyBase() = default;
    virtual ~NoCopyBase();
private:
    NoCopyBase& operator=(const NoCopyBase&); //不实现
    NoCopyBase(const NoCopyBase&); //不实现
};
class NoCopy : public NoCopyBase{
};
```
    +   定义一个基类，将拷贝构造函数、拷贝赋值函数声明为`private`。理论上一定程度上就可以阻止生成对应的函数了，但是，在类内部的成员以及友元函数仍能够调用吗导致链接错误，因此，通过派生，派生类里基类成员函数私有，并且派生类成员函数不能使用基类私有成员。

    +   派生方式不一定是`public`，也可以是其他派生方式。


### 静态成员函数

静态成员函数既可以在类内部定义也可以在类外部定义，但是在类外部定义的时候，不能重复使用`static`关键字，该关键字只需要在申明的时候使用即可。 静态成员函数不与任何的对象绑定在一起，一个类只定义一次。真因为不与对象绑定，静态成员函数不包含`this`指针，同时也不能申明为`const`的成员函数，不能再静态成员函数内部使用`this`指针。主要的使用规则如下：

+   **静态成员函数不能调用类的非静态成员，非静态成员函数可以使用静态数据成员**：在静态成员函数定义的时候对象还没有申明、初始化也就不存在对象的非静态数据成员、`this`指针，继而，静态成员函数不能使用`this`指针，也不能使用对象的非静态数据成员。

+   **静态成员函数的地址可用普通函数指针储存，而普通成员函数地址需要用 类成员函数指针来储存。** 『类成员函数指针有什么特殊之处』
```C++
class base{ 
static int func1(); 
int func2(); 
}; 

int (*pf1)()=&base::func1;//普通的函数指针 
int (base::*pf2)()=&base::func2;//成员函数指针 
```

+   **静态成员函数不可以同时声明为 virtual、const、volatile函数。**
```C++
class base{ 
virtual static void func1();//错误 
static void func2() const;//错误 
static void func3() volatile;//错误 
}; 
```

### 常量成员函数

常量成员函数是在类中申明函数以及定义函数的时候在函数参数列表之后有`const`的一类成员函数。其主要作用和对象的`this`指针相关。`this`指针是常量指针，不能修改其保存的地址，可以指向非常量，表示可以通过`this`指针来修改对象。当函数被申明为常量成员函数的时候，此时表示对象不能使用该常量成员函数来修改对象。

常量成员函数不管是常量对象还是非常量对象都能调用。因此，对于不修改对象的函数尽量申明为常量成员函数，但是对于非常量成员函数只能由非常量对象调用。但是**构造函数和析构函数不能是常量成员函数**。

+   非常量对象调用非常量成员函数         （正确）

+   非常量对象调用常量成员函数           （正确）

+   常量对象调用常量成员函数             （正确）

+   常量对象调用非常量成员函数           （错误）

常量成员函数在申明和定义的时候都需在参数列表之后指明`const`。对于有的成员函数需要有常量版本和非常量版本，比如下标操作符`[]`，一般来说常量版本返回函数也是常量的。

但是对于类内部的`mutable`成员，可以在常量成员函数最后那个被修改。

### 内联函数

内联函数定义在头文件里面，可以在类里面申明指明`inline`也可以定义的时候指明`inline`，两个地方都指明也可以。 但是关键字`inline`只是发出一个『请求』，具体是否作为内联取决于
编译器。

### constexpt 函数

### 与类相关的非成员函数

一般来说与类相关的非成员函数申明在类之外和类的申明在同一个头文件，定义和类的成员函数一起定义，不属于类的接口。

#### 类型转换函数

类型转换运算符(函数)是一种特殊的**成员函数**，将一个类类型值转换为其他类型。
```C++
operator type () const;
```
+   type 表示某种类型，也可以是指针或者引用类型。

+   不能申明返回类型(返回类型和type一样)，参数列表为空。

当一个类申明了类型转换符之后，类可以隐式的从类类型转换为对应的类型，如
```C++
// 类类型转换测试
#include <iostream>
using namespace std;
class SmallInt{
public:
    SmallInt(int i = 0):val(i){std::cout << "Constructor Called." << std::endl;}
    SmallInt& operator=(const SmallInt& rhs){
        val = rhs.val;
        std::cout << "Operator= Called." << std::endl;
        return *this;
    }
    operator int() const{ 
        std::cout << "Operator int() Called." <<std::endl;
        return val;
    }
private:
    std::size_t val;
};
int main(){
    SmallInt s1 = 10;
    //类类型转换为整型，由于operator int()的存在
    cout << s1 + 10 <<endl;
    return 0;
}
```
在意想不到的情况下隐式的类类型转换会导致错误，因此C++11引入显式类型转换符。将类型转换函数声明为`explicit`。在需要类型转换的时候需要使用`static_cast<type>`，但是用在当做判断条件的时候会自动转换。(Primer P516)
```C++
cout << static_cast<int> (s1) + 3 << endl;
if(s1){}
while(s1){}
···
```


存在的二义性问题处理原则(Primer P519)

[运算符重载]:./操作符重载.md